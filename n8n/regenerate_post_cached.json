{
  "name": "Regenerate Post Part (Cached)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "regenerate_post",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "regenerate-post-webhook"
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "action",
              "value": "={{ $json.action }}"
            },
            {
              "name": "link",
              "value": "={{ $json.link }}"
            },
            {
              "name": "current_title",
              "value": "={{ $json.current_title }}"
            },
            {
              "name": "current_text",
              "value": "={{ $json.current_text }}"
            },
            {
              "name": "channelId",
              "value": "={{ $json.channelId }}"
            },
            {
              "name": "channelName",
              "value": "={{ $json.channelName }}"
            }
          ]
        },
        "options": {}
      },
      "id": "extract-data",
      "name": "Extract Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Проверка кэша перед запросом к Firecrawl\nconst url = $input.first().json.link;\nconst cacheKey = `firecrawl_${Buffer.from(url).toString('base64').replace(/[^a-zA-Z0-9]/g, '')}`;\nconst cachedData = $workflow.getStaticData('global')[cacheKey];\n\nif (cachedData) {\n  const cacheAge = Date.now() - cachedData.timestamp;\n  const maxAge = 60 * 60 * 1000; // 1 час\n  \n  if (cacheAge < maxAge) {\n    return [{\n      json: {\n        ...cachedData.data,\n        fromCache: true,\n        cacheAge: Math.round(cacheAge / 1000 / 60)\n      }\n    }];\n  } else {\n    delete $workflow.getStaticData('global')[cacheKey];\n  }\n}\n\nreturn [{ json: { url: url, shouldFetch: true } }];"
      },
      "id": "check-cache",
      "name": "Check Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.shouldFetch }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "cache-condition",
      "name": "Cache Condition",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 200]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "options": {
          "includeImages": true,
          "includeLinks": true,
          "includeHtml": false,
          "includeMarkdown": true,
          "includeJson": false,
          "maxLength": 10000
        },
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "firecrawlApi"
      },
      "id": "firecrawl-scrape",
      "name": "Scrape with Firecrawl",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1120, 100],
      "credentials": {
        "firecrawlApi": {
          "id": "firecrawl-credentials",
          "name": "Firecrawl API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Сохранение результата в кэш\nconst url = $('Extract Data').item.json.link;\nconst firecrawlData = $input.first().json;\nconst cacheKey = `firecrawl_${Buffer.from(url).toString('base64').replace(/[^a-zA-Z0-9]/g, '')}`;\n\n$workflow.getStaticData('global')[cacheKey] = {\n  data: firecrawlData,\n  timestamp: Date.now(),\n  url: url\n};\n\nreturn [{\n  json: {\n    ...firecrawlData,\n    fromCache: false,\n    cached: true\n  }\n}];"
      },
      "id": "save-to-cache",
      "name": "Save to Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 100]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "markdown",
              "value": "={{ $json.markdown }}"
            },
            {
              "name": "action",
              "value": "={{ $('Extract Data').item.json.action }}"
            },
            {
              "name": "current_title",
              "value": "={{ $('Extract Data').item.json.current_title }}"
            },
            {
              "name": "current_text",
              "value": "={{ $('Extract Data').item.json.current_text }}"
            },
            {
              "name": "channelId",
              "value": "={{ $('Extract Data').item.json.channelId }}"
            },
            {
              "name": "channelName",
              "value": "={{ $('Extract Data').item.json.channelName }}"
            }
          ]
        },
        "options": {}
      },
      "id": "prepare-ai-data",
      "name": "Prepare AI Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "model": "gpt-4",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Ты - AI агент для перегенерации частей постов в Telegram каналах. Создавай качественный контент на основе предоставленных данных."
            },
            {
              "role": "user",
              "content": "ДЕЙСТВИЕ: {{ $json.action }}\n\nТЕКУЩИЙ ЗАГОЛОВОК: {{ $json.current_title }}\nТЕКУЩИЙ ТЕКСТ: {{ $json.current_text }}\n\nНАСТРОЙКИ КАНАЛА:\n- ID: {{ $json.channelId }}\n- Название: {{ $json.channelName }}\n\nПОЛНЫЙ КОНТЕНТ СТРАНИЦЫ (Markdown):\n{{ $json.markdown }}\n\nЗАДАЧИ:\n1. Если action = 'regenerate_title': создай новый провокационный заголовок на основе полного контента\n2. Если action = 'regenerate_text': создай новый текст поста на основе полного контента\n\nПРАВИЛА:\n- Используй информацию из полного контента для более детального анализа\n- Создавай уникальный контент, а не просто пересказывай\n- Адаптируй стиль под канал ({{ $json.channelName }})\n- Для заголовков: провокационные, цепляющие, с элементами драмы\n- Для текста: информативный, с анализом и выводами\n\nФОРМАТ ОТВЕТА (JSON):\n```json\n{\n  \"new_title\": \"Новый заголовок (только если action = regenerate_title)\",\n  \"new_text\": \"Новый текст поста (только если action = regenerate_text)\"\n}\n```\n\nОтвечай ТОЛЬКО JSON."
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 1000
        }
      },
      "id": "ai-regenerate",
      "name": "AI Regenerate",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [1780, 200],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Обработка ответа AI агента для перегенерации\nconst aiResponse = $input.first().json;\n\n// Парсим JSON ответ от AI\nlet parsedResponse;\ntry {\n  parsedResponse = JSON.parse(aiResponse.output || aiResponse);\n} catch (error) {\n  // Если это уже объект, используем как есть\n  parsedResponse = aiResponse.output || aiResponse;\n}\n\n// Получаем действие из исходных данных\nconst action = $('Extract Data').item.json.action;\n\n// Формируем ответ в зависимости от действия\nlet finalResponse = {};\n\nif (action === 'regenerate_title' && parsedResponse.new_title) {\n  finalResponse = {\n    new_title: parsedResponse.new_title,\n    success: true,\n    action: 'regenerate_title'\n  };\n} else if (action === 'regenerate_text' && parsedResponse.new_text) {\n  finalResponse = {\n    new_text: parsedResponse.new_text,\n    success: true,\n    action: 'regenerate_text'\n  };\n} else {\n  finalResponse = {\n    success: false,\n    error: 'Не удалось получить новый контент от AI',\n    action: action\n  };\n}\n\nreturn [{ json: finalResponse }];"
      },
      "id": "process-response",
      "name": "Process Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $('Process Response').item.json }}"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2220, 200]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Extract Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Data": {
      "main": [
        [
          {
            "node": "Check Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Cache": {
      "main": [
        [
          {
            "node": "Cache Condition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Condition": {
      "main": [
        [
          {
            "node": "Scrape with Firecrawl",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare AI Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape with Firecrawl": {
      "main": [
        [
          {
            "node": "Save to Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Cache": {
      "main": [
        [
          {
            "node": "Prepare AI Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare AI Data": {
      "main": [
        [
          {
            "node": "AI Regenerate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Regenerate": {
      "main": [
        [
          {
            "node": "Process Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-26T12:00:00.000Z",
  "versionId": "1"
}
