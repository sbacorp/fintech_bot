{
  "name": "Create News Post (Supabase Cache)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "create_news",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "create-news-webhook"
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "title",
              "value": "={{ $json.title }}"
            },
            {
              "name": "description", 
              "value": "={{ $json.description }}"
            },
            {
              "name": "link",
              "value": "={{ $json.link }}"
            },
            {
              "name": "image",
              "value": "={{ $json.image }}"
            },
            {
              "name": "category",
              "value": "={{ $json.category }}"
            },
            {
              "name": "urgency",
              "value": "={{ $json.urgency }}"
            },
            {
              "name": "publishedAt",
              "value": "={{ $json.publishedAt }}"
            },
            {
              "name": "source",
              "value": "={{ $json.source }}"
            },
            {
              "name": "channelId",
              "value": "={{ $json.channelId }}"
            },
            {
              "name": "channelName",
              "value": "={{ $json.channelName }}"
            },
            {
              "name": "channelDescription",
              "value": "={{ $json.channelDescription }}"
            },
            {
              "name": "userId",
              "value": "={{ $json.userId }}"
            },
            {
              "name": "aiPrompt",
              "value": "={{ $json.aiPrompt }}"
            }
          ]
        },
        "options": {}
      },
      "id": "extract-data",
      "name": "Extract Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Проверка кэша в Supabase перед запросом к Firecrawl\nconst url = $input.first().json.link;\n\n// Запрос к Supabase для проверки кэша\nconst supabaseUrl = $vars.SUPABASE_URL;\nconst supabaseKey = $vars.SUPABASE_ANON_KEY;\n\ntry {\n  const response = await fetch(`${supabaseUrl}/rest/v1/firecrawl_cache?url=eq.${encodeURIComponent(url)}&expires_at=gt.${new Date().toISOString()}`, {\n    method: 'GET',\n    headers: {\n      'apikey': supabaseKey,\n      'Authorization': `Bearer ${supabaseKey}`,\n      'Content-Type': 'application/json'\n    }\n  });\n\n  if (response.ok) {\n    const data = await response.json();\n    \n    if (data && data.length > 0) {\n      const cacheEntry = data[0];\n      \n      // Вычисляем возраст кэша в минутах\n      const createdAt = new Date(cacheEntry.created_at);\n      const now = new Date();\n      const cacheAge = Math.round((now.getTime() - createdAt.getTime()) / (1000 * 60));\n      \n      return [{\n        json: {\n          markdown: cacheEntry.markdown,\n          fromCache: true,\n          cacheAge: cacheAge,\n          url: url\n        }\n      }];\n    }\n  }\n} catch (error) {\n  console.log('Cache check error:', error);\n}\n\n// Если кэша нет или ошибка, продолжаем с обычным запросом\nreturn [{\n  json: {\n    url: url,\n    shouldFetch: true\n  }\n}];"
      },
      "id": "check-supabase-cache",
      "name": "Check Supabase Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.shouldFetch }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "cache-condition",
      "name": "Cache Condition",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 200]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "options": {
          "includeImages": true,
          "includeLinks": true,
          "includeHtml": false,
          "includeMarkdown": true,
          "includeJson": false,
          "maxLength": 10000
        },
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "firecrawlApi"
      },
      "id": "firecrawl-scrape",
      "name": "Scrape with Firecrawl",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1120, 100],
      "credentials": {
        "firecrawlApi": {
          "id": "firecrawl-credentials",
          "name": "Firecrawl API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Сохранение результата Firecrawl в Supabase кэш\nconst url = $('Extract Data').item.json.link;\nconst firecrawlData = $input.first().json;\nconst markdown = firecrawlData.markdown;\n\nif (!markdown) {\n  return [{\n    json: {\n      ...firecrawlData,\n      fromCache: false,\n      cached: false,\n      error: 'No markdown data to cache'\n    }\n  }];\n}\n\n// Запрос к Supabase для сохранения в кэш\nconst supabaseUrl = $vars.SUPABASE_URL;\nconst supabaseKey = $vars.SUPABASE_ANON_KEY;\n\n// Вычисляем время истечения (1 час от сейчас)\nconst expiresAt = new Date();\nexpiresAt.setHours(expiresAt.getHours() + 1);\n\ntry {\n  const response = await fetch(`${supabaseUrl}/rest/v1/firecrawl_cache`, {\n    method: 'POST',\n    headers: {\n      'apikey': supabaseKey,\n      'Authorization': `Bearer ${supabaseKey}`,\n      'Content-Type': 'application/json',\n      'Prefer': 'resolution=merge-duplicates'\n    },\n    body: JSON.stringify({\n      url: url,\n      markdown: markdown,\n      expires_at: expiresAt.toISOString()\n    })\n  });\n\n  if (response.ok) {\n    console.log('Successfully saved to Supabase cache');\n    \n    return [{\n      json: {\n        ...firecrawlData,\n        fromCache: false,\n        cached: true,\n        expiresAt: expiresAt.toISOString()\n      }\n    }];\n  } else {\n    console.error('Failed to save to cache:', response.status, await response.text());\n  }\n} catch (error) {\n  console.error('Cache save error:', error);\n}\n\n// Если не удалось сохранить в кэш, возвращаем данные без кэширования\nreturn [{\n  json: {\n    ...firecrawlData,\n    fromCache: false,\n    cached: false,\n    error: 'Failed to save to cache'\n  }\n}];"
      },
      "id": "save-to-supabase-cache",
      "name": "Save to Supabase Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 100]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "markdown",
              "value": "={{ $json.markdown }}"
            },
            {
              "name": "title",
              "value": "={{ $('Extract Data').item.json.title }}"
            },
            {
              "name": "description",
              "value": "={{ $('Extract Data').item.json.description }}"
            },
            {
              "name": "link",
              "value": "={{ $('Extract Data').item.json.link }}"
            },
            {
              "name": "category",
              "value": "={{ $('Extract Data').item.json.category }}"
            },
            {
              "name": "urgency",
              "value": "={{ $('Extract Data').item.json.urgency }}"
            },
            {
              "name": "source",
              "value": "={{ $('Extract Data').item.json.source }}"
            },
            {
              "name": "channelId",
              "value": "={{ $('Extract Data').item.json.channelId }}"
            },
            {
              "name": "channelName",
              "value": "={{ $('Extract Data').item.json.channelName }}"
            },
            {
              "name": "channelDescription",
              "value": "={{ $('Extract Data').item.json.channelDescription }}"
            },
            {
              "name": "userId",
              "value": "={{ $('Extract Data').item.json.userId }}"
            },
            {
              "name": "aiPrompt",
              "value": "={{ $('Extract Data').item.json.aiPrompt }}"
            }
          ]
        },
        "options": {}
      },
      "id": "prepare-ai-data",
      "name": "Prepare AI Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "model": "gpt-4",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Ты - профессиональный AI агент для создания постов в Telegram каналы о финтехе, банках, криптовалютах и финансовых новостях. Создавай качественный контент на основе предоставленных данных."
            },
            {
              "role": "user", 
              "content": "ДАННЫЕ НОВОСТИ:\n- Заголовок: {{ $json.title }}\n- Описание: {{ $json.description }}\n- Ссылка: {{ $json.link }}\n- Категория: {{ $json.category }}\n- Срочность: {{ $json.urgency }}\n- Источник: {{ $json.source }}\n\nНАСТРОЙКИ КАНАЛА:\n- ID: {{ $json.channelId }}\n- Название: {{ $json.channelName }}\n- Описание: {{ $json.channelDescription }}\n\nAI ПРОМПТ:\n{{ $json.aiPrompt }}\n\nПОЛНЫЙ КОНТЕНТ СТРАНИЦЫ (Markdown):\n{{ $json.markdown }}\n\nПРАВИЛА:\n1. Следуй инструкциям в AI промпте\n2. Адаптируй стиль под канал ({{ $json.channelName }})\n3. Включи ссылку на источник\n4. Создай качественный контент\n5. Используй информацию из полного контента страницы для более детального анализа\n\nФОРМАТ ОТВЕТА (JSON):\n```json\n{\n  \"title\": \"Заголовок поста\",\n  \"content\": \"Текст поста с форматированием\",\n  \"hashtags\": [\"#финансы\", \"#новости\"],\n  \"image\": \"URL изображения или null\",\n  \"link\": \"Ссылка на источник\",\n  \"metadata\": {\n    \"wordCount\": 150,\n    \"hasEmojis\": true,\n    \"hasHashtags\": true\n  }\n}\n```\n\nОтвечай ТОЛЬКО JSON."
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 2000
        }
      },
      "id": "ai-generate-post",
      "name": "AI Generate Post",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [1780, 200],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Обработка ответа AI агента\nconst aiResponse = $input.first().json;\n\n// Парсим JSON ответ от AI\nlet parsedResponse;\ntry {\n  parsedResponse = JSON.parse(aiResponse.output || aiResponse);\n} catch (error) {\n  // Если это уже объект, используем как есть\n  parsedResponse = aiResponse.output || aiResponse;\n}\n\n// Формируем финальный ответ в стандартном формате\nconst finalResponse = {\n  title: parsedResponse.title,\n  content: parsedResponse.content,\n  hashtags: parsedResponse.hashtags || [],\n  image: parsedResponse.image || null,\n  link: $('Extract Data').item.json.link,\n  metadata: {\n    wordCount: (parsedResponse.content || '').length,\n    hasEmojis: /[\\u{1F600}-\\u{1F64F}]|[\\u{1F300}-\\u{1F5FF}]|[\\u{1F680}-\\u{1F6FF}]|[\\u{1F1E0}-\\u{1F1FF}]|[\\u{2600}-\\u{26FF}]|[\\u{2700}-\\u{27BF}]/u.test(\n      parsedResponse.content || ''\n    ),\n    hasHashtags: (parsedResponse.hashtags || []).length > 0\n  }\n};\n\n// Возвращаем обработанный результат\nreturn [{ json: finalResponse }];"
      },
      "id": "process-ai-response",
      "name": "Process AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 200]
    },
    {
      "parameters": {
        "url": "={{ $vars.BOT_WEBHOOK_URL }}/webhook/post-created",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "channelId",
              "value": "={{ $('Extract Data').item.json.channelId }}"
            },
            {
              "name": "channelName", 
              "value": "={{ $('Extract Data').item.json.channelName }}"
            },
            {
              "name": "userId",
              "value": "={{ $('Extract Data').item.json.userId }}"
            },
            {
              "name": "originalNews",
              "value": "={{ {\n  \"title\": $('Extract Data').item.json.title,\n  \"description\": $('Extract Data').item.json.description,\n  \"link\": $('Extract Data').item.json.link,\n  \"category\": $('Extract Data').item.json.category,\n  \"urgency\": $('Extract Data').item.json.urgency,\n  \"source\": $('Extract Data').item.json.source\n} }}"
            },
            {
              "name": "generatedPost",
              "value": "={{ $json }}"
            },
            {
              "name": "success",
              "value": "true"
            }
          ]
        },
        "options": {}
      },
      "id": "send-to-bot",
      "name": "Send to Bot",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2220, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $('Process AI Response').item.json }}"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2440, 200]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Extract Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Data": {
      "main": [
        [
          {
            "node": "Check Supabase Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Supabase Cache": {
      "main": [
        [
          {
            "node": "Cache Condition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Condition": {
      "main": [
        [
          {
            "node": "Scrape with Firecrawl",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare AI Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape with Firecrawl": {
      "main": [
        [
          {
            "node": "Save to Supabase Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Supabase Cache": {
      "main": [
        [
          {
            "node": "Prepare AI Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare AI Data": {
      "main": [
        [
          {
            "node": "AI Generate Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Generate Post": {
      "main": [
        [
          {
            "node": "Process AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Response": {
      "main": [
        [
          {
            "node": "Send to Bot",
            "type": "main",
            "index": 0
          },
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Bot": {
      "main": [
        []
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-26T12:00:00.000Z",
  "versionId": "1"
}
